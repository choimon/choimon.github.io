---
title: '이중 동작 모드(Dual Mode operation)'
last_modified_at: 2021-07-09T20:01
categories:
  - OS
tags:
  - dual mode
toc: true
toc_sticky: true
---
# Summary 
운영체제의 보호 기법이라고 할 수 있는 이중 동작 모드에 대해 알아본다. [^fn1]

# 이중 모드(Dual mode)
한 프로그램에서 일어난 에러가 다른 프로그램의 데이터를 변경시키거나 운영체제 수행을 방해하게 된다면 다른 프로세스에 악영향을 끼칠 것이다.[^fn2] 예를 들어, 한 프로세스가 무한루프에 빠지면, 다른 프로세스가 수행하지 못하게 되어 동작을 방해한다. 이러한 오류를 예방하여 적절하게 수행할 수 있도록 운영체제는 다음과 같이 두 가지 동작 모드를 가지고 있다. 
- 사용자 모드(User Mode)
- 커널 모드(kernel, system, monitor, privileged, supervisor mode)

## 이중 동작 모드의 구조

이중 동작 모드는 사용자 모드와 커널 모드로 이루어져 있다. 사용자 모드는 사용자를 위한 동작을, 커널 모드는 운영체제를 위한 동작을 담당한다. 만약 사용자 모드에서 특권 명령 (privileged instruction)을 실행하려 하면 시스템은 이 명령을 불법으로 간주하고 수행하지 못하게 한다. 
- 특권 명령에는 인터럽트 핸들링, 사용자 모드에서 커널 모드로 전환, 입출력 관리 등이 있다.

사용자가 사용하는 응용 프로그램은 사용자 모드에서 작동된다. 해당 프로그램에서 입출력 요청과 같은 운영체제에 시스템 사용을 요청하게 되면 커널 모드로 바꾸어서 요청된 시스템을 실행한다. 그 후에 다시 사용자 모드로 전환한다. 

두 모드를 구분하기 위해 모드 비트(mode bit)를 플래그(flag)로 사용한다. 이 하나의 비트는 컴퓨터의 하드웨어(CPU 내부의 레지스터)에 추가되어있다. 커널 모드 일 때 비트값은 0, 사용자 모드일 때는 비트 값이 1이다. 이 비트를 사용해서 운영체제를 위하여 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있다. 

<figure>
<img src='{{"/assets/images/posts/20210706_os_dualmode.png"| relative_url}}' alt='운영체제 이중모드'>
  <!-- <figcaption>컴퓨터 구조</figcaption> -->
</figure>


### 모드 전환
컴퓨터가 켜지고 사용자 애플리케이션(앱)을 실행할 때 어떻게 모드가 변하는지 알아본다.[^fn3]
1. 컴퓨터 부팅 과정 - 커널 모드 
2. 앱 실행 과정 - 커널 모드 
3. 앱 실행 중 - 사용자 모드 
4. 인터럽트 발생 후 처리 과정 - 커널 모드 
5. 인터럽트 처리 후 - 사용자 모드 

사용자가 하드웨어 자원에 접근하는 것은 위험하다. 이런 접근은 모두 커널 모드로 운영체제에서 처리한다. 프로그램에서 소프트웨어 인터럽트를 발생 시켜 운영체제에 위임한다. 4번 인터럽트 발생 후 처리 과정을 자세히 살펴본다. 
- 하드웨어 인터럽트 발생 후 CPU로 인터럽트 신호 요청 (사용자 모드)
- CPU에서 모드 플래그를 커널 모드 값으로 설정
- 해당 하드웨어 ISR(Interrupt Service Routine - 해당 인터럽트를 어떻게 처리할지 적혀있는 코드)으로 이동 (커널 모드)
- 인터럽트 처리 (커널 모드)
- 인터럽트 처리 완료 후 CPU 모드 플래그를 다시 사용자 모드 값으로 설정 
- 원래 애플리케이션 위치로 복귀 (사용자 모드)

애플리케이션이 실행할 때 위와 같은 모드 변경이 반복적으로 일어난다.


# 하드웨어 보호 
이중 모드는 운영체제의 보호 기능 중 하나이다. 
운영체제가 보호하는 하드웨어는 입출력 장치, 메모리,CPU가 있다.[^fn3]

## 입출력 장치 보호 
입출력 장치를 통해 여러 정보가 컴퓨터로 입력되어, 외부 장치로 출력이 된다. 
입출력 장치를 이용하게 되면 발생할 수 있는 문제점이 있다. 
- 여러 입출력 장치의 사용으로 인한 혼선이 발생한다. 
- 사용자가 자신의 데이터가 아닌 다른 사용자의 데이터에 입출력한다. 

입출력 장치에 여러 사용자의 데이터가 뒤엉켜서 들어오거나 다른 사용자 데이터에 접근하려는 경우, 제대로 된 수행을 하지 못하는 문제가 발생하기 때문에 막아야 한다. 

위 같은 경우를 해결하기 위해,  `in`, `out`과 같은 입출력 명령을 특권 명령(privileged instruction)으로 설정한다. 사용자 앱에서 입출력을 사용할 때 운영체제를 통해서 수행해야 한다. 이때 사용되는 것이 소프트웨어 인터럽트다. 여러 프로그램이 동시에 입출력을 사용하려고 할 때 운영체제 내부에서(ISR) 순서를 정해서 혼선을 막아 줄 수 있다. 사용자가 다른 사용자의 데이터를 읽으려 하는 경우, 운영체제가 요청한 사용자가 해당 데이터에 접근할 수 있는 여부를 판단하여 거부시킬 수 있다. 


## 메모리 보호 
메모리에는 운영체제와 여러 사용자 앱이 존재한다. 한 앱이 자신에게 할당된 메모리 영역 외의 영역, 즉 운영체제나 다른 앱의 메모리 영역에 침범하게 되면 위험하다.

![memory protection in dual mode]({{"/assets/images/posts/20210706_dualmode_memory_1.png"| relative_url}})

위 그림의 경우, User1이 OS, User2, User3에 접근하는 것을 막아야 한다. 
CPU는 address bus를 통해 메모리 주소에 접근한다. Address bus에서 User1 프로그램이 실행되는 동안 User1이 할당된 메모리 주소 범위 안의 경우에만 접근할 수 있도록 검사한다. 이때 사용되는 것이 MMU다. 

Memory Management Unit(MMU)은 Address bus 중간에 설치된 하드웨어 칩이다. MMU는 그림처럼 두 개의 레지스터를 통해 해당 프로그램의 주소 범위를 저장한다. 

![memory protection in dual mode 2]({{"/assets/images/posts/20210706_dualmode_memory_2.png"| relative_url}})
User1이 수행되는 동안 운영체제는 이 프로그램의 주소 범위를 MMU에 설정(특권 명령)한다. User1의 시작주소가 1024, 끝 주소가 4048인 경우에 base는 1024, limit은 4048이 된다. User1이 수행될 동안 이 범위 안 주소값만 address bus를 통과한다. 
이 범위 밖의 주소 값이 MMU에 들어오면, MMU에서 내부 인터럽트를 발생 시켜 CPU에 신호를 보낸다. CPU는 관련된 ISR로 이동하여 해당 프로그램을 강제 종료시킨다. 이런 잘못된 메모리 접근을 segment violation이라고 한다. 


### CPU 보호 
한 프로그램이 CPU를 독점하게 되면 다른 프로그램은 수행되지 못하기 때문에 CPU 독점은 방지해야 한다.[^fn4]

```java
while(true)
{
  // do something
}
```
위와 같은 코드는 무한 반복을 일으켜 CPU를 독점하게 된다. 
이를 해결하기 위해 타이머를 두어 일정 시간이 지나면 타이머 인터럽트를 발생시킬 수 있다. 인터럽트가 발생하면 운영체제 내의 ISR로 이동한다. ISR에서 각 프로그램의 CPU 점유 시간을 측정하여 적절히 분배되도록 조정한다.



# References
[^fn1]: [neon518님 tistory](https://neos518.tistory.com/115){:target="_blank"}
[^fn2]: [geeksforgeeks](https://www.geeksforgeeks.org/dual-mode-operations-os/){:target="_blank"}
[^fn3]: [codemcd님 velog](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-3.-%EC%9D%B4%EC%A4%91%EB%AA%A8%EB%93%9C%EC%99%80-%EB%B3%B4%ED%98%B8){:target="_blank"}
[^fn4]: [stackoverflow](https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use){:target="_blank"}





